/-
Copyright (c) 2025 Eric Hearn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Hearn
-/
import Lean
import TAIL.Types

/-!
# TAIL Environment Utilities

Environment introspection utilities for verification.
All checks use proper Lean environment queries, not text parsing.
-/

namespace TAIL

open Lean Meta

/-! ## Module Membership Detection -/

/-- Get the module name for a declaration, if it exists in the environment -/
def getModuleName (env : Environment) (declName : Name) : Option Name := do
  let idx ← env.getModuleIdxFor? declName
  env.header.moduleNames[idx.toNat]?

/-- Check if a declaration belongs to a specific module -/
def isInModule (env : Environment) (declName : Name) (moduleName : Name) : Bool :=
  match getModuleName env declName with
  | some name => name == moduleName
  | none => false

/-- Get all declarations defined in a specific module -/
def getModuleDeclarations (env : Environment) (moduleName : Name) : List Name := Id.run do
  let mut result : List Name := []
  for (name, _) in env.constants.toList do
    if isInModule env name moduleName then
      result := name :: result
  return result.reverse

/-! ## Internal Name Detection -/

/-- Check if a string contains a substring -/
private def containsSubstr (s : String) (sub : String) : Bool :=
  (s.splitOn sub).length > 1

/-- Check if a name is an internal/auxiliary declaration -/
def isInternalName (name : Name) : Bool :=
  name.isInternal ||
  containsSubstr name.toString "._" ||
  containsSubstr name.toString ".match_" ||
  containsSubstr name.toString ".proof_"

/-- Check if a name is an auto-generated theorem from a structure/inductive definition.
    These include injEq, sizeOf_spec, inj, noConfusion, etc. -/
def isAutoGeneratedTheorem (name : Name) : Bool :=
  let nameStr := name.toString
  -- Structure/inductive auto-generated theorems
  nameStr.endsWith ".injEq" ||
  nameStr.endsWith ".inj" ||
  nameStr.endsWith ".sizeOf_spec" ||
  nameStr.endsWith ".noConfusion" ||
  nameStr.endsWith ".noConfusionType" ||
  -- Check for patterns like Foo.mk.injEq, Foo.mk.inj, etc.
  containsSubstr nameStr ".mk.injEq" ||
  containsSubstr nameStr ".mk.inj" ||
  containsSubstr nameStr ".mk.sizeOf_spec" ||
  containsSubstr nameStr ".mk.noConfusion"

/-- Check if a name is a structure field accessor theorem (proof-valued fields).
    Field accessors for proof-valued fields are generated as theorems. -/
def isStructureFieldTheorem (env : Environment) (name : Name) : Bool :=
  -- Get parent name (e.g., MyStruct from MyStruct.myField)
  match name with
  | .str parent _ =>
    -- Check if parent is a structure
    match env.find? parent with
    | some (.inductInfo info) =>
      -- It's an inductive; check if this is a structure (single constructor)
      info.ctors.length == 1
    | _ => false
  | _ => false

/-! ## Type Checking Utilities -/

/-- Check if an expression is Prop (syntactically) -/
def isPropSyntactic (e : Expr) : Bool :=
  e.isSort && e.sortLevel! == Level.zero

/-- Check if an expression is definitionally equal to Prop -/
def isPropDefEq (e : Expr) : MetaM Bool := do
  isDefEq e (Expr.sort Level.zero)

/-- Get declaration kind as a string -/
def getDeclKind (info : ConstantInfo) : String :=
  match info with
  | .axiomInfo _ => "axiom"
  | .defnInfo _ => "def"
  | .thmInfo _ => "theorem"
  | .opaqueInfo _ => "opaque"
  | .quotInfo _ => "quot"
  | .inductInfo _ => "inductive"
  | .ctorInfo _ => "constructor"
  | .recInfo _ => "recursor"

/-! ## Re-Import Test (Module Visibility Checking) -/

/-- Check if a module name belongs to the project (starts with project prefix) -/
def isProjectModule (moduleName : Name) (projectPrefix : String) : Bool :=
  moduleName.toString.startsWith projectPrefix

/-- Get all visible declarations that come from project modules.
    Checks module membership rather than name prefix, since declarations
    may be in the global namespace (e.g., StatementOfTheorem, mainTheorem). -/
def getVisibleProjectDeclarations (env : Environment) (projectPrefix : String) : List Name := Id.run do
  let mut visible : List Name := []

  for (name, _) in env.constants.toList do
    -- Skip internal names
    if isInternalName name then continue
    -- Skip names starting with _private (module-private declarations)
    if name.toString.startsWith "_private" then continue

    -- Check if this declaration comes from a project module
    match getModuleName env name with
    | some modName =>
      if isProjectModule modName projectPrefix then
        visible := name :: visible
    | none => continue

  return visible.reverse

/-- Filter to user-defined declarations (defs and theorems) -/
def filterUserDeclarations (env : Environment) (names : List Name) : List Name :=
  names.filter fun name =>
    match env.find? name with
    | some (.defnInfo _) | some (.thmInfo _) => true
    | _ => false

/-- Check if a module is a "core" module (MainTheorem or ProofOfMainTheorem) -/
def isCoreModule (moduleName : Name) (projectPrefix : String) : Bool :=
  let mainMod := s!"{projectPrefix}.MainTheorem".toName
  let proofMod := s!"{projectPrefix}.ProofOfMainTheorem".toName
  moduleName == mainMod || moduleName == proofMod

/-- Check if a declaration is from a Definitions/ module -/
def isFromDefinitionsModule (env : Environment) (name : Name) (projectPrefix : String) : Bool :=
  match getModuleName env name with
  | some modName => modName.toString.startsWith s!"{projectPrefix}.Definitions"
  | none => false

/-- Check if a declaration is from a Proofs/ module -/
def isFromProofsModule (env : Environment) (name : Name) (projectPrefix : String) : Bool :=
  match getModuleName env name with
  | some modName => modName.toString.startsWith s!"{projectPrefix}.Proofs"
  | none => false

/-- The re-import test: verify only allowed declarations are exported from the proof module.
    - Strict mode: only StatementOfTheorem and mainTheorem allowed
    - Default mode: StatementOfTheorem, mainTheorem, and Definitions/ content allowed

    Note: Proofs/ declarations are checked separately. The module system (Lean 4.27+) ensures
    that private imports are not re-exported. We verify that ProofOfMainTheorem uses private
    imports for Proofs/ modules, so their declarations won't be visible to downstream importers. -/
def checkModuleVisibility (env : Environment) (projectPrefix : String)
    (statementName theoremName : Name) (mode : VerificationMode) : CheckResult := Id.run do
  -- Get all declarations from project modules in the loaded environment
  let projectDecls := getVisibleProjectDeclarations env projectPrefix

  -- Filter to user-defined declarations (defs and theorems)
  let userDecls := filterUserDeclarations env projectDecls

  -- Determine allowed declarations based on mode
  let isAllowed (d : Name) : Bool :=
    -- Always allowed: StatementOfTheorem and mainTheorem
    if d == statementName || d == theoremName then true
    -- In default mode, Definitions/ content is allowed (it's human-reviewed)
    else if mode == .default && isFromDefinitionsModule env d projectPrefix then true
    -- Proofs/ declarations: trusted to be hidden by module system's private import
    -- (ProofOfMainTheorem should use `import`, not `public import`, for Proofs/)
    else if isFromProofsModule env d projectPrefix then true
    -- MainTheorem module declarations (besides StatementOfTheorem) are a concern
    else false

  -- Any project declaration that's not allowed is a violation
  let violations := userDecls.filter (!isAllowed ·)

  if violations.isEmpty then
    let modeDesc := if mode == .strict then "strict mode" else "default mode"
    CheckResult.pass "Module Visibility"
      s!"Only allowed declarations are exported ({modeDesc})"
  else
    let details := violations.map fun v =>
      let modName := match getModuleName env v with
        | some m => m.toString
        | none => "unknown"
      s!"Leaked: {v} (from {modName})"
    CheckResult.fail "Module Visibility"
      s!"{violations.length} internal declarations leaked from project modules"
      details

end TAIL
