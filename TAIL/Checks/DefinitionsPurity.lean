/-
Copyright (c) 2025 Eric Hearn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Hearn
-/
import TAIL.Types
import TAIL.Config
import TAIL.Environment
import TAIL.Checks.Structure

/-!
# Definitions Purity Check

Verify that files in the Definitions/ folder:
- Only import from Mathlib or other Definitions/ files (not Proofs/)
- Only contain definitions (def, abbrev, structure, inductive, class, instance)
- No theorems allowed
- No axioms/opaques allowed
- No sorry usage

This check only runs in default mode when a Definitions/ folder exists.
-/

namespace TAIL.Checks

open Lean Meta

/-- Allowed import prefixes for Definitions/ files -/
def definitionsAllowedImportPrefixes : List String :=
  ["Mathlib", "Init", "Std", "Lean", "Qq", "Aesop", "ProofWidgets", "Batteries"]

/-- Check imports for a Definitions/ module -/
def checkDefinitionsModuleImports (env : Environment) (moduleName : Name) (resolved : ResolvedConfig) :
    List String × Bool :=
  match getModuleImports env moduleName with
  | none => (["Could not retrieve imports"], false)
  | some imports =>
    let violations := imports.toList.filterMap fun imp =>
      let modName := imp.module
      let modStr := modName.toString
      -- Check if this is a project import
      if modStr.startsWith resolved.projectPrefix then
        -- Only Definitions/ imports are allowed from project
        if resolved.isDefinitionsModule modName then
          none  -- OK
        else
          some s!"  - {modStr} (only Definitions/ imports allowed)"
      else if !definitionsAllowedImportPrefixes.any (modStr.startsWith ·) then
        some s!"  - {modStr} (non-Mathlib import)"
      else
        none
    (violations, violations.isEmpty)

/-- Check if a declaration uses sorry by checking axiom dependencies -/
private def usagesSorry (env : Environment) (declName : Name) : MetaM Bool := do
  try
    let mut visited : Std.HashSet Name := {}
    let mut toVisit : Array Name := #[declName]

    while h : toVisit.size > 0 do
      let curr := toVisit[toVisit.size - 1]'(by omega)
      toVisit := toVisit.pop

      if visited.contains curr then continue
      visited := visited.insert curr

      let some currInfo := env.find? curr | continue

      match currInfo with
      | .axiomInfo _ =>
        if curr == ``sorryAx then return true
      | .defnInfo val =>
        let deps := val.value.getUsedConstants
        toVisit := toVisit ++ deps.filter (!visited.contains ·)
      | .thmInfo val =>
        let deps := val.value.getUsedConstants
        toVisit := toVisit ++ deps.filter (!visited.contains ·)
      | _ => continue

    return false
  catch _ =>
    return false

/-- Check declarations in a Definitions/ module -/
def checkDefinitionsModuleDeclarations (env : Environment) (moduleName : Name) : MetaM (List String × Bool) := do
  let decls := TAIL.getModuleDeclarations env moduleName
  let userDecls := decls.filter (!TAIL.isInternalName ·)

  let mut violations : List String := []

  for decl in userDecls do
    match env.find? decl with
    | some (.thmInfo _) =>
      -- Skip auto-generated theorems from structures/inductives
      if TAIL.isAutoGeneratedTheorem decl then
        continue
      -- Skip structure field theorems (proof-valued fields)
      else if TAIL.isStructureFieldTheorem env decl then
        continue
      else
        violations := violations ++ [s!"  - theorem {decl} (theorems not allowed in Definitions/)"]
    | some (.axiomInfo _) =>
      violations := violations ++ [s!"  - axiom {decl} (axioms not allowed)"]
    | some (.opaqueInfo _) =>
      violations := violations ++ [s!"  - opaque {decl} (opaque not allowed)"]
    | some (.defnInfo _) | some (.inductInfo _) =>
      -- Check for sorry usage
      let usesSorry ← usagesSorry env decl
      if usesSorry then
        violations := violations ++ [s!"  - {decl} uses sorry (not allowed in Definitions/)"]
    | _ => continue  -- ctorInfo, recInfo, quotInfo are fine

  return (violations, violations.isEmpty)

/-- Check that all Definitions/ files follow the rules -/
def checkDefinitionsPurity (resolved : ResolvedConfig) : MetaM CheckResult := do
  -- Skip if no Definitions/ folder or in strict mode
  if resolved.mode == .strict then
    return CheckResult.pass "Definitions Purity"
      "Skipped (strict mode - no Definitions/ folder allowed)"

  if resolved.definitionsPath.isNone then
    return CheckResult.pass "Definitions Purity"
      "Skipped (no Definitions/ folder present)"

  let env ← getEnv

  -- Find all modules that are in Definitions/
  let allModules := env.header.moduleNames
  let defModules := allModules.filter fun name =>
    resolved.isDefinitionsModule name

  if defModules.isEmpty then
    return CheckResult.pass "Definitions Purity"
      "No modules found in Definitions/ folder"

  let mut allViolations : List String := []
  let mut moduleCount := 0

  for modName in defModules do
    moduleCount := moduleCount + 1

    -- Check imports
    let (importViolations, importsOk) := checkDefinitionsModuleImports env modName resolved
    if !importsOk then
      allViolations := allViolations ++ [s!"Import violations in {modName}:"] ++ importViolations

    -- Check declarations (now in MetaM due to sorry checking)
    let (declViolations, declsOk) ← checkDefinitionsModuleDeclarations env modName
    if !declsOk then
      allViolations := allViolations ++ [s!"Declaration violations in {modName}:"] ++ declViolations

  if allViolations.isEmpty then
    return CheckResult.pass "Definitions Purity"
      s!"All {moduleCount} Definitions/ modules are valid"
  else
    return CheckResult.fail "Definitions Purity"
      "Definitions/ folder contains disallowed content" allViolations

end TAIL.Checks
