/-
Copyright (c) 2025 Eric Hearn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Hearn
-/
import TAIL.Types
import TAIL.Config
import TAIL.Environment
import TAIL.Checks.Structure
import TAIL.Utils

/-!
# Definitions Purity Check

Verify that files in the Definitions/ folder:
- Only import from Mathlib or other Definitions/ files (not Proofs/)
- Only contain definitions (def, abbrev, structure, inductive, class, instance)
- No theorems allowed
- No axioms/opaques allowed
- No sorry usage

This check only runs in default mode when a Definitions/ folder exists.
-/

namespace TAIL.Checks

open Lean Meta

/-- Check imports for a Definitions/ module -/
def checkDefinitionsModuleImports (env : Environment) (moduleName : Name) (resolved : ResolvedConfig) :
    List String × Bool :=
  match TAIL.getModuleImports env moduleName with
  | none => (["Could not retrieve imports"], false)
  | some imports =>
    let violations := imports.toList.filterMap fun imp =>
      let modName := imp.module
      let modStr := modName.toString
      -- Check if this is a project import
      if modStr.startsWith resolved.projectPrefix then
        -- Only Definitions/ imports are allowed from project
        if resolved.isDefinitionsModule modName then
          none  -- OK
        else
          some s!"  - {modStr} (only Definitions/ imports allowed)"
      else if !TAIL.standardLibraryPrefixes.any (modStr.startsWith ·) then
        some s!"  - {modStr} (non-Mathlib import)"
      else
        none
    (violations, violations.isEmpty)

/-- Check declarations in a Definitions/ module -/
def checkDefinitionsModuleDeclarations (env : Environment) (moduleName : Name)
    (index : Option TAIL.EnvironmentIndex := none) : MetaM (List String × Bool) := do
  let decls := TAIL.getModuleDeclarations env moduleName index
  let userDecls := decls.filter (!TAIL.isInternalName ·)

  let mut violationsArray : Array String := #[]

  for decl in userDecls do
    match env.find? decl with
    | some (.thmInfo _) =>
      -- Skip auto-generated theorems from structures/inductives
      if TAIL.isAutoGeneratedTheorem decl then
        continue
      -- Skip structure field theorems (proof-valued fields)
      else if TAIL.isStructureFieldTheorem env decl then
        continue
      else
        violationsArray := violationsArray.push s!"  - theorem {decl} (theorems not allowed in Definitions/)"
    | some (.axiomInfo _) =>
      violationsArray := violationsArray.push s!"  - axiom {decl} (axioms not allowed)"
    | some (.opaqueInfo _) =>
      violationsArray := violationsArray.push s!"  - opaque {decl} (opaque not allowed)"
    | some (.defnInfo _) | some (.inductInfo _) =>
      -- Check for sorry usage
      let usesSorry ← TAIL.usagesSorry env decl
      if usesSorry then
        violationsArray := violationsArray.push s!"  - {decl} uses sorry (not allowed in Definitions/)"
    | _ => continue  -- ctorInfo, recInfo, quotInfo are fine

  return (violationsArray.toList, violationsArray.isEmpty)

/-- Check that all Definitions/ files follow the rules -/
def checkDefinitionsPurity (resolved : ResolvedConfig) (index : Option TAIL.EnvironmentIndex := none) : MetaM CheckResult := do
  -- Skip if no Definitions/ folder or in strict mode
  if resolved.mode == .strict then
    return CheckResult.pass "Definitions Purity"
      "Skipped (strict mode - no Definitions/ folder allowed)"

  if resolved.definitionsPath.isNone then
    return CheckResult.pass "Definitions Purity"
      "Skipped (no Definitions/ folder present)"

  let env ← getEnv

  -- Find all modules that are in Definitions/
  let allModules := env.header.moduleNames
  let defModules := allModules.filter fun name =>
    resolved.isDefinitionsModule name

  if defModules.isEmpty then
    return CheckResult.pass "Definitions Purity"
      "No modules found in Definitions/ folder"

  let mut allViolationsArray : Array String := #[]
  let mut moduleCount := 0

  for modName in defModules do
    moduleCount := moduleCount + 1

    -- Check imports
    let (importViolations, importsOk) := checkDefinitionsModuleImports env modName resolved
    if !importsOk then
      allViolationsArray := allViolationsArray.push s!"Import violations in {modName}:"
      allViolationsArray := allViolationsArray ++ importViolations.toArray

    -- Check declarations (now in MetaM due to sorry checking)
    let (declViolations, declsOk) ← checkDefinitionsModuleDeclarations env modName index
    if !declsOk then
      allViolationsArray := allViolationsArray.push s!"Declaration violations in {modName}:"
      allViolationsArray := allViolationsArray ++ declViolations.toArray

  if allViolationsArray.isEmpty then
    return CheckResult.pass "Definitions Purity"
      s!"All {moduleCount} Definitions/ modules are valid"
  else
    return CheckResult.fail "Definitions Purity"
      "Definitions/ folder contains disallowed content" allViolationsArray.toList

end TAIL.Checks
