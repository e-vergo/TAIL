/-
Copyright (c) 2025 Eric Hearn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Hearn
-/
import TAIL.OleanReader
import TAIL.Types
import TAIL.Config
import TAIL.Utils
import Batteries.Data.String.Matcher

/-!
# TAIL Checks - Helpers

Shared utilities and lookup functions used across all verification checks.
-/

namespace TAIL.Checks

open Lean

/-! ## Standard Axioms -/

/-- The four standard axioms accepted in verified Lean proofs -/
def standardAxioms : List Name :=
  [`propext, `Quot.sound, ``Classical.choice, ``funext]

/-- Check if an axiom is one of the standard accepted axioms -/
def isStandardAxiom (n : Name) : Bool :=
  standardAxioms.contains n

/-! ## Module Lookup Helpers -/

/-- Find a module by name in the array of modules -/
def findModule (modules : Array OleanModuleInfo) (name : Name) : Option OleanModuleInfo :=
  modules.find? (·.name == name)

/-- Find a declaration by name in a module -/
def findDecl (mod : OleanModuleInfo) (name : Name) : Option OleanDeclInfo :=
  mod.declarations.find? (·.name == name)

/-- Get all non-internal declarations from a module -/
def getUserDeclarations (mod : OleanModuleInfo) : Array OleanDeclInfo :=
  mod.declarations.filter (!·.isInternal)

/-- Check if an import is a project import -/
def isProjectImport (moduleName : Name) (projectPrefix : String) : Bool :=
  moduleName.toString.startsWith projectPrefix

/-! ## Declaration Classification Helpers -/

/-- Check if a declaration name should be skipped in soundness checks.
    Skips auto-generated declarations but includes _private.* (user-written private code). -/
def shouldSkipDeclaration (name : Name) : Bool :=
  let nameStr := name.toString
  TAIL.containsSubstr nameStr ".rec" ||
  TAIL.containsSubstr nameStr ".recOn" ||
  TAIL.containsSubstr nameStr ".casesOn" ||
  TAIL.containsSubstr nameStr ".mk.injEq" ||
  TAIL.containsSubstr nameStr ".noConfusion" ||
  TAIL.containsSubstr nameStr ".noConfusionType" ||
  TAIL.containsSubstr nameStr ".below" ||
  TAIL.containsSubstr nameStr ".ibelow" ||
  TAIL.containsSubstr nameStr ".brecOn" ||
  TAIL.containsSubstr nameStr ".binductionOn" ||
  TAIL.containsSubstr nameStr ".sizeOf_spec" ||
  TAIL.containsSubstr nameStr ".ctorIdx"

/-- Check if a name looks like an auto-generated definition (structure helpers, recursors, etc.) -/
def isAutoGeneratedDef (name : Name) : Bool :=
  let nameStr := name.toString
  TAIL.containsSubstr nameStr ".rec" ||
  TAIL.containsSubstr nameStr ".recOn" ||
  TAIL.containsSubstr nameStr ".casesOn" ||
  TAIL.containsSubstr nameStr ".below" ||
  TAIL.containsSubstr nameStr ".ibelow" ||
  TAIL.containsSubstr nameStr ".brecOn" ||
  TAIL.containsSubstr nameStr ".binductionOn" ||
  TAIL.containsSubstr nameStr ".noConfusion" ||
  TAIL.containsSubstr nameStr ".noConfusionType" ||
  TAIL.containsSubstr nameStr ".ctorIdx" ||
  TAIL.containsSubstr nameStr ".mk.sizeOf_spec" ||
  TAIL.containsSubstr nameStr ".sizeOf_spec" ||
  name.isInternal

/-- Check if a name is a field projector for any of the given structures -/
def isFieldProjector (name : Name) (structures : Array Name) : Bool :=
  structures.any fun structName =>
    let structPrefix := structName.toString ++ "."
    let nameStr := name.toString
    nameStr.startsWith structPrefix && !TAIL.containsSubstr nameStr ".rec"

/-- Check if a name looks like an auto-generated theorem -/
def isAutoGeneratedTheorem (name : Name) : Bool :=
  let nameStr := name.toString
  TAIL.containsSubstr nameStr ".rec" ||
  TAIL.containsSubstr nameStr ".recOn" ||
  TAIL.containsSubstr nameStr ".casesOn" ||
  TAIL.containsSubstr nameStr ".below" ||
  TAIL.containsSubstr nameStr ".ibelow" ||
  TAIL.containsSubstr nameStr ".brecOn" ||
  TAIL.containsSubstr nameStr ".binductionOn" ||
  TAIL.containsSubstr nameStr ".noConfusion" ||
  TAIL.containsSubstr nameStr ".noConfusionType" ||
  TAIL.containsSubstr nameStr ".sizeOf_spec" ||
  TAIL.containsSubstr nameStr ".eq_def" ||
  TAIL.containsSubstr nameStr ".ext" ||
  TAIL.containsSubstr nameStr ".mk.injEq" ||
  TAIL.containsSubstr nameStr ".mk.sizeOf_spec"

/-! ## Type Analysis Helpers -/

/-- Check if a type expression is trivially True.
    True is represented as a constant with name `True`. -/
def isTrivialTrue (type : Expr) : Bool :=
  match type with
  | .const name _ => name == ``True
  | _ => false

/-- Check if a type ultimately returns Prop (handles multi-argument functions).
    For types like `∀ A B C, SomeProp`, recursively checks through foralls. -/
partial def returnsProp (type : Expr) : Bool :=
  type.isProp || (type.isForall && returnsProp type.bindingBody!)

end TAIL.Checks
