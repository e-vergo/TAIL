/-
Copyright (c) 2025 Eric Hearn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Hearn
-/
import TAIL.Checks.Helpers

/-!
# TAIL Checks - Content Rules

Checks for folder content rules:
- Proofs/ content (only lemmas and Prop-valued definitions)
- Definitions/ content (only defs/structures, no theorems or sorry)
- Definitions/ semantic risks (warnings for notation, macro, syntax that could mislead)
-/

namespace TAIL.Checks

open Lean

/-! ## 6. Proofs Content Check -/

/-- Check imports for a Proofs/ module -/
def checkProofsModuleImports (mod : OleanModuleInfo) (resolved : ResolvedConfig) :
    Array String × Bool := Id.run do
  let mut violations : Array String := #[]

  for imp in mod.imports do
    let modName := imp.module
    let modStr := modName.toString

    if modName == resolved.mainTheoremModule then
      violations := violations.push s!"  - Cannot import MainTheorem from Proofs/"
    else if modName == resolved.proofOfMainTheoremModule then
      violations := violations.push s!"  - Cannot import ProofOfMainTheorem from Proofs/"
    else if TAIL.isStandardLibraryImport modName then
      continue
    else if modStr.startsWith resolved.projectPrefix then
      if resolved.mode == .default && resolved.isDefinitionsModule modName then
        continue
      else if resolved.isProofsModule modName then
        continue
      else
        violations := violations.push s!"  - Unexpected project import: {modStr}"

  (violations, violations.isEmpty)

/-- Check that all Proofs/ files follow the rules -/
def checkProofsContent (resolved : ResolvedConfig) (modules : Array OleanModuleInfo) : IO CheckResult := do
  -- Skip if no Proofs/ folder
  if resolved.proofsPath.isNone then
    return CheckResult.pass CheckCategory.contentRules "Proofs Content"
      "Skipped (no Proofs/ folder present)"

  -- Find all modules in Proofs/
  let proofsModules := modules.filter fun mod =>
    resolved.isProofsModule mod.name

  if proofsModules.isEmpty then
    return CheckResult.pass CheckCategory.contentRules "Proofs Content"
      "No modules found in Proofs/ folder"

  let mut allViolations : Array String := #[]
  let mut moduleCount := 0

  for mod in proofsModules do
    moduleCount := moduleCount + 1

    -- Check import restrictions
    let (importViolations, importsOk) := checkProofsModuleImports mod resolved
    if !importsOk then
      allViolations := allViolations.push s!"Import violations in {mod.name}:"
      allViolations := allViolations ++ importViolations

    -- First pass: collect all structures/inductives (not allowed in Proofs/)
    let userDecls := getUserDeclarations mod
    let mut detectedStructures : Array Name := #[]

    for decl in userDecls do
      if decl.kind == .ind then
        detectedStructures := detectedStructures.push decl.name
        allViolations := allViolations.push s!"  - structure/inductive {decl.name} (not allowed in Proofs/)"

    -- Second pass: check other declarations
    for decl in userDecls do
      -- Skip structures (already handled above)
      if decl.kind == .ind then continue

      -- Check for sorry usage (unless skipped)
      if !resolved.skipSorryCheck && decl.usesSorry then
        allViolations := allViolations.push s!"  - {decl.name} uses sorry in {mod.name}"

      -- Check for defs without proof obligation (must return Prop)
      -- Filter out auto-generated structure helpers and field projectors
      if decl.kind.isDef && !isAutoGeneratedDef decl.name && !isFieldProjector decl.name detectedStructures then
        -- Use the improved multi-argument Prop check
        if !returnsProp decl.type then
          allViolations := allViolations.push s!"  - def {decl.name} (defs in Proofs/ must return Prop)"

  if allViolations.isEmpty then
    return CheckResult.pass CheckCategory.contentRules "Proofs Content"
      s!"All {moduleCount} Proofs/ modules are valid"
  else
    return CheckResult.fail CheckCategory.contentRules "Proofs Content"
      "Proofs/ folder contains disallowed content" allViolations.toList

/-! ## 7. Definitions Content Check -/

/-- Check imports for a Definitions/ module -/
def checkDefinitionsModuleImports (mod : OleanModuleInfo) (resolved : ResolvedConfig) :
    Array String × Bool := Id.run do
  let mut violations : Array String := #[]

  for imp in mod.imports do
    let modName := imp.module
    let modStr := modName.toString

    if modStr.startsWith resolved.projectPrefix then
      -- Only Definitions/ imports are allowed from project
      if resolved.isDefinitionsModule modName then
        continue
      else
        violations := violations.push s!"  - {modStr} (only Definitions/ imports allowed)"
    else if !TAIL.isStandardLibraryImport modName then
      violations := violations.push s!"  - {modStr} (non-Mathlib import)"

  (violations, violations.isEmpty)

/-- Check that all Definitions/ files follow the rules -/
def checkDefinitionsContent (resolved : ResolvedConfig) (modules : Array OleanModuleInfo) : IO CheckResult := do
  -- Skip if strict mode
  if resolved.mode == .strict then
    return CheckResult.pass CheckCategory.contentRules "Definitions Content"
      "Skipped (strict mode - no Definitions/ folder allowed)"

  -- Skip if no Definitions/ folder
  if resolved.definitionsPath.isNone then
    return CheckResult.pass CheckCategory.contentRules "Definitions Content"
      "Skipped (no Definitions/ folder present)"

  -- Find all modules in Definitions/
  let defModules := modules.filter fun mod =>
    resolved.isDefinitionsModule mod.name

  if defModules.isEmpty then
    return CheckResult.pass CheckCategory.contentRules "Definitions Content"
      "No modules found in Definitions/ folder"

  let mut allViolations : Array String := #[]
  let mut moduleCount := 0

  for mod in defModules do
    moduleCount := moduleCount + 1

    -- Check imports
    let (importViolations, importsOk) := checkDefinitionsModuleImports mod resolved
    if !importsOk then
      allViolations := allViolations.push s!"Import violations in {mod.name}:"
      allViolations := allViolations ++ importViolations

    -- Note: Theorems ARE allowed in Definitions/ (needed for dependent definitions)
    -- Note: Opaques are checked globally by checkOpaquesInSource
    -- Note: Sorry is checked globally in Soundness check

  if allViolations.isEmpty then
    return CheckResult.pass CheckCategory.contentRules "Definitions Content"
      s!"All {moduleCount} Definitions/ modules are valid"
  else
    return CheckResult.fail CheckCategory.contentRules "Definitions Content"
      "Definitions/ folder contains disallowed content" allViolations.toList

/-! ## 7b. Definitions Semantic Risks Check (Warnings Only) -/

/-- Patterns that could affect how MainTheorem.lean is interpreted. -/
private def semanticRiskPatterns : List (String × String) :=
  [ ("notation", "custom notation")
  , ("scoped notation", "scoped notation")
  , ("macro ", "macro definition")
  , ("macro_rules", "macro rules")
  , ("syntax ", "syntax declaration")
  , ("instance", "instance (check for Coe)")
  ]

/-- Check if a line contains a semantic risk pattern.
    Returns (hasRisk, patternName) if found. -/
private def hasSemanticRisk (line : String) : Option String := Id.run do
  let trimmed := line.trim
  -- Skip comments
  if trimmed.startsWith "--" then return none
  -- Skip lines inside doc comments
  if trimmed.startsWith "/-" then return none

  for (pattern, name) in semanticRiskPatterns do
    if trimmed.startsWith pattern then
      -- Special case: "instance" should only warn if it's a Coe instance
      if pattern == "instance" then
        if trimmed.containsSubstr "Coe" || trimmed.containsSubstr "CoeT" ||
           trimmed.containsSubstr "CoeTC" || trimmed.containsSubstr "CoeFun" then
          return some "coercion instance"
        else
          continue
      return some name
  return none

/-- Scan Definitions/ folder for semantic risk patterns.
    These are WARNINGS, not errors - they prompt extra human review. -/
def checkDefinitionsSemanticRisks (resolved : ResolvedConfig) : IO (Array String) := do
  -- Skip if strict mode or no Definitions/ folder
  if resolved.mode == .strict then return #[]
  let some defPath := resolved.definitionsPath | return #[]

  let leanFiles ← TAIL.discoverLeanFiles defPath
  let mut warnings : Array String := #[]

  for filePath in leanFiles do
    let content ← IO.FS.readFile filePath
    let lines := content.splitOn "\n"
    let relPath := filePath.toString.replace (resolved.projectRoot.toString ++ "/") ""

    let mut lineNumber := 0
    let mut fileRisks : Array String := #[]

    for line in lines do
      lineNumber := lineNumber + 1
      if let some riskName := hasSemanticRisk line then
        fileRisks := fileRisks.push s!"{riskName} (line {lineNumber})"

    if !fileRisks.isEmpty then
      let risksStr := String.intercalate ", " fileRisks.toList
      warnings := warnings.push s!"  WARNING: {relPath} contains {risksStr} - verify MainTheorem.lean semantics"

  return warnings

end TAIL.Checks
